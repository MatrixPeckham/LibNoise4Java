/*
 * DEFAULT LICENSE
 * Do not make illegal copies
 * This software is provided as is, without any warranty at all
 * Not responsible for any damage to anything that may occur
 * Copyright Â© 2012 William Peckham
 */
package com.matrixpeckham.libnoise.module;

import com.matrixpeckham.libnoise.util.exceptions.ExceptionNoModule;

/**
 * Abstract base class for noise modules.
 * <p>
 * A <i>noise module</i> is an object that calculates and outputs a value given
 * a three-dimensional input value.
 * <p>
 * Each type of noise module uses a specific method to calculate an output
 * value. Some of these methods include:
 * <p>
 * - Calculating a value using a coherent-noise function or some other
 * mathematical function. - Mathematically changing the output value from
 * another noise module in various ways. - Combining the output values from two
 * noise modules in various ways.
 * <p>
 * An application can use the output values from these noise modules in the
 * following ways:
 * <p>
 * - It can be used as an elevation value for a terrain height map - It can be
 * used as a grayscale (or an RGB-channel) value for a procedural texture - It
 * can be used as a position value for controlling the movement of a simulated
 * lifeform.
 * <p>
 * A noise module defines a near-infinite 3-dimensional texture. Each position
 * in this "texture" has a specific value.
 * <p>
 * <b>Combining noise modules</b>
 * <p>
 * Noise modules can be combined with other noise modules to generate complex
 * output values. A noise module that is used as a source of output values for
 * another noise module is called a <i>source module</i>. Each of these source
 * modules may be connected to other source modules, and so on.
 * <p>
 * There is no limit to the number of noise modules that can be connected
 * together in this way. However, each connected noise module increases the time
 * required to calculate an output value.
 * <p>
 * <b>Noise-module categories</b>
 * <p>
 * The noise module classes that are included in libnoise can be roughly divided
 * into five categories.
 * <p>
 * <i>Generator Modules</i>
 * <p>
 * A generator module outputs a value generated by a coherent-noise function or
 * some other mathematical function.
 * <p>
 * Examples of generator modules include: - noise::module::Const: Outputs a
 * constant value. - noise::module::Perlin: Outputs a value generated by a
 * Perlin-noise function. - noise::module::Voronoi: Outputs a value generated by
 * a Voronoi-cell function.
 * <p>
 * <i>Modifier Modules</i>
 * <p>
 * A modifer module mathematically modifies the output value from a source
 * module.
 * <p>
 * Examples of modifier modules include: - noise::module::Curve: Maps the output
 * value from the source module onto an arbitrary function curve. -
 * noise::module::Invert: Inverts the output value from the source module.
 * <p>
 * <i>Combiner Modules</i>
 * <p>
 * A combiner module mathematically combines the output values from two or more
 * source modules together.
 * <p>
 * Examples of combiner modules include: - noise::module::Add: Adds the two
 * output values from two source modules. - noise::module::Max: Outputs the
 * larger of the two output values from two source modules.
 * <p>
 * <i>Selector Modules</i>
 * <p>
 * A selector module uses the output value from a <i>control module</i>
 * to specify how to combine the output values from its source modules.
 * <p>
 * Examples of selector modules include: - noise::module::Blend: Outputs a value
 * that is linearly interpolated between the output values from two source
 * modules; the interpolation weight is determined by the output value from the
 * control module. - noise::module::Select: Outputs the value selected from one
 * of two source modules chosen by the output value from a control module.
 * <p>
 * <i>Transformer Modules</i>
 * <p>
 * A transformer module applies a transformation to the coordinates of the input
 * value before retrieving the output value from the source module. A
 * transformer module does not modify the output value.
 * <p>
 * Examples of transformer modules include: - RotatePoint: Rotates the
 * coordinates of the input value around the origin before retrieving the output
 * value from the source module. - ScalePoint: Multiplies each coordinate of the
 * input value by a constant value before retrieving the output value from the
 * source module.
 * <p>
 * <b>Connecting source modules to a noise module</b>
 * <p>
 * An application connects a source module to a noise module by passing the
 * source module to the SetSourceModule() method.
 * <p>
 * The application must also pass an <i>index value</i> to SetSourceModule() as
 * well. An index value is a numeric identifier for that source module. Index
 * values are consecutively numbered starting at zero.
 * <p>
 * To retrieve a reference to a source module, pass its index value to the
 * GetSourceModule() method.
 * <p>
 * Each noise module requires the attachment of a certain number of source
 * modules before it can output a value. For example, the noise::module::Add
 * module requires two source modules, while the noise::module::Perlin module
 * requires none. Call the GetSourceModuleCount() method to retrieve the number
 * of source modules required by that module.
 * <p>
 * For non-selector modules, it usually does not matter which index value an
 * application assigns to a particular source module, but for selector modules,
 * the purpose of a source module is defined by its index value. For example,
 * consider the noise::module::Select noise module, which requires three source
 * modules. The control module is the source module assigned an index value of
 * 2. The control module determines whether the noise module will output the
 * value from the source module assigned an index value of 0 or the output value
 * from the source module assigned an index value of 1.
 * <p>
 * <b>Generating output values with a noise module</b>
 * <p>
 * Once an application has connected all required source modules to a noise
 * module, the application can now begin to generate output values with that
 * noise module.
 * <p>
 * To generate an output value, pass the ( @a x, @a y, @a z ) coordinates of an
 * input value to the GetValue() method.
 * <p>
 * <b>Using a noise module to generate terrain height maps or textures</b>
 * <p>
 * One way to generate a terrain height map or a texture is to first allocate a
 * 2-dimensional array of floating-point values. For each array element, pass
 * the array subscripts as @a x and @a y coordinates to the GetValue() method
 * (leaving the @a z coordinate set to zero) and place the resulting output
 * value into the array element.
 * <p>
 * <b>Creating your own noise modules</b>
 * <p>
 * Create a class that publicly derives from noise::module::AbstractModule.
 * <p>
 * In the constructor, call the base class' constructor while passing the return
 * value from GetSourceModuleCount() to it.
 * <p>
 * Override the GetSourceModuleCount() pure virtual method. From this method,
 * return the number of source modules required by your noise module.
 * <p>
 * Override the GetValue() pure virtual method. For generator modules, calculate
 * and output a value given the coordinates of the input value. For other
 * modules, retrieve the output values from each source module referenced in the
 * protected @a m_pSourceModule array, mathematically combine those values, and
 * return the combined value.
 * <p>
 * When developing a noise module, you must ensure that your noise module does
 * not modify any source module or control module connected to it; a noise
 * module can only modify the output value from those source modules. You must
 * also ensure that if an application fails to connect all required source
 * modules via the SetSourceModule() method and then attempts to call the
 * GetValue() method, your module will raise an assertion.
 * <p>
 * It shouldn't be too difficult to create your own noise module. If you still
 * have some problems, take a look at the source code for noise::module::Add,
 * which is a very simple noise module.
 *
 * @author William Matrix Peckham
 */
public abstract class AbstractModule implements Module {

    /**
     * Array of modules to use as source.
     * <p>
     */
    protected Module[] sourceModule;

    /**
     * Constructor
     * <p>
     * <p>
     */
    public AbstractModule() {
        int sourceModuleCount = getSourceModuleCount();
        //create the array of pointers
        if (sourceModuleCount > 0) {
            sourceModule = new Module[sourceModuleCount];
            for (int i = 0; i < sourceModuleCount; i++) {
                sourceModule[i] = null;
            }
        }
    }

    /**
     * Returns a reference to a source module connected to this noise module.
     *
     * @param index The index value assigned to the source module.
     *
     * @return A reference to the source module.
     *
     * @noise.pre The index value ranges from 0 to one less than the number of
     * source modules required by this noise module.
     * @noise.pre A source module with the specified index value has been added
     * to this noise module via a call to SetSourceModule().
     *
     * @throws ExceptionNoModule See the preconditions for more information.
     *
     * Each noise module requires the attachment of a certain number of source
     * modules before an application can call the GetValue() method.
     */
    @Override
    public Module getSourceModule(int index) {
        if (index >= getSourceModuleCount() || index < 0 || sourceModule[index]
                == null) {
            throw new ExceptionNoModule();
        }
        return sourceModule[index];
    }

    @Override
    public void setSourceModule(int index, Module source) {
        if (index >= getSourceModuleCount() || index < 0) {
            throw new IllegalArgumentException("source index out of bounds");
        }
        sourceModule[index] = source;
    }

    @Override
    public double getValue(double x) {
        return getValue(x, 0);
    }

    @Override
    public double getValue(double x, double y) {
        return getValue(x, y, 0);
    }

    @Override
    public double getValue(double x, double y, double z) {
        return getValue(x, y, z, 0);
    }

    @Override
    public double getValue(double x, double y, double z, double w) {
        return getValue(x, y, z, w, 0, 0);
    }

    @Override
    public double getValue(double x, double y, double z, double w, double u,
            double v) {
        return getNoise(x, y, z, w, u, v).value;
    }

}
